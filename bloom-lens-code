// Flower Drop Script (no tween version)
// @input SceneObject flower1
// @input SceneObject flower2
// @input SceneObject flower3
// @input SceneObject flower4
// @input Component.Text successText
// @input Component.Text failText
// @input Component.Image retryButton

var flowerObjects = [script.flower1, script.flower2, script.flower3, script.flower4];
var currentFlowerObj = null;
var isDropping = false;
var stopped = false;
var gameOver = false;
var failed = false; // Track if the game failed (to show retry option)
var celebrating = false; // Track if we're in celebration mode

// Game progression
var currentFlower = 1; // Current flower number (1-4)
var totalFlowers = 4; // Total number of flowers
var baseSwingSpeed = 0.2; // Base swing speed (increased from 0.15)
var speedIncrement = 0.05; // Speed increase per flower

// Movement settings
var dropSpeed = 10;
var groundY = -200;

// Pendulum settings
var pivotY = -1500; // Y position of the pivot point (much further down, ~2.7x lower than -150)
var armLength = 1480; // Distance from pivot to flower center (increased to compensate for much lower pivot)
var maxAngle = 5 // Maximum swing angle in degrees (reduced from 15 to 5 for very subtle motion)
var swingSpeed = baseSwingSpeed; // Will be updated based on current flower
var currentAngle = -maxAngle; // Start at left side
var angleDirection = 1; // 1 for clockwise, -1 for counter-clockwise

// Vase detection settings (middle 1/3 of screen)
var vaseLeftBound = -50; // Approximate left edge of vase (middle 1/3)
var vaseRightBound = 50; // Approximate right edge of vase (middle 1/3)

// Celebration dance settings
var celebrationFlowers = []; // Flowers that are dancing
var danceTime = 0; // Time counter for dance animation

// Set current flower object and hide others (except landed ones)
function setCurrentFlower() {
    currentFlowerObj = flowerObjects[currentFlower - 1];
    
    // Hide only the non-landed flowers
    for (var i = currentFlower; i < flowerObjects.length; i++) {
        if (flowerObjects[i]) {
            flowerObjects[i].enabled = false;
        }
    }
    
    // Show the current flower
    if (currentFlowerObj) {
        currentFlowerObj.enabled = true;
    }
    
    print("Switched to flower " + currentFlower);
}

// Initialize UI elements as hidden
function initializeUI() {
    if (script.successText) script.successText.enabled = false;
    if (script.failText) script.failText.enabled = false;
    if (script.retryButton) script.retryButton.enabled = false;
}

// Update swing speed based on current flower
function updateSwingSpeed() {
    swingSpeed = baseSwingSpeed + (currentFlower - 1) * speedIncrement;
    print("Flower " + currentFlower + " - Speed: " + swingSpeed);
}

// Reset flower position and rotation
function resetFlowerPosition() {
    if (!currentFlowerObj) return;
    
    var pos = currentFlowerObj.getTransform().getLocalPosition();
    var angleRad = currentAngle * (Math.PI / 180);
    pos.x = Math.sin(angleRad) * armLength;
    pos.y = pivotY + Math.cos(angleRad) * armLength;
    currentFlowerObj.getTransform().setLocalPosition(pos);
    
    // Reset rotation
    var rotation = currentFlowerObj.getTransform().getLocalRotation();
    rotation.z = -angleRad;
    currentFlowerObj.getTransform().setLocalRotation(rotation);
}

// Reset game to initial state
function resetGame() {
    isDropping = false;
    stopped = false;
    gameOver = false;
    failed = false;
    celebrating = false;
    currentFlower = 1; // Reset to first flower
    currentAngle = -maxAngle;
    angleDirection = 1;
    celebrationFlowers = [];
    danceTime = 0;
    
    // Hide all flowers first
    for (var i = 0; i < flowerObjects.length; i++) {
        if (flowerObjects[i]) {
            flowerObjects[i].enabled = false;
        }
    }
    
    // Set first flower and update speed
    setCurrentFlower();
    updateSwingSpeed();
    
    // Reset flower position
    resetFlowerPosition();
    
    // Hide UI elements
    initializeUI();
}

// Advance to next flower
function nextFlower() {
    currentFlower++;
    isDropping = false;
    stopped = false;
    gameOver = false;
    failed = false;
    currentAngle = -maxAngle;
    angleDirection = 1;
    
    // Switch to next flower and update speed
    setCurrentFlower();
    updateSwingSpeed();
    
    // Reset flower position
    resetFlowerPosition();
    
    print("Starting flower " + currentFlower + " of " + totalFlowers);
}

// Start celebration dance
function startCelebration() {
    celebrating = true;
    danceTime = 0;
    
    // Make all flowers visible for the dance
    celebrationFlowers = [];
    for (var i = 0; i < flowerObjects.length; i++) {
        if (flowerObjects[i]) {
            flowerObjects[i].enabled = true;
            celebrationFlowers.push({
                flower: flowerObjects[i],
                angle: i * 90, // Start at different angles
                radius: 80,
                speed: 2 + i * 0.5 // Different speeds for each flower
            });
        }
    }
    
    print("ðŸŽ‰ Starting celebration dance!");
    
    // Show replay button after 5 seconds
    var replayEvent = script.createEvent("DelayedCallbackEvent");
    replayEvent.bind(function() {
        if (script.retryButton) {
            script.retryButton.enabled = true;
        }
        print("Replay button available - tap anywhere to restart!");
    });
    replayEvent.reset(5.0); // 5 second delay
}

// Update celebration dance
function updateCelebration() {
    if (!celebrating) return;
    
    danceTime += 0.05; // Increment dance time
    
    for (var i = 0; i < celebrationFlowers.length; i++) {
        var flowerData = celebrationFlowers[i];
        var flower = flowerData.flower;
        
        // Calculate dancing position in a circle
        var angle = flowerData.angle + danceTime * flowerData.speed;
        var x = Math.sin(angle) * flowerData.radius;
        var y = Math.cos(angle) * flowerData.radius + 50; // Center around y=50
        
        // Set position
        var pos = flower.getTransform().getLocalPosition();
        pos.x = x;
        pos.y = y;
        flower.getTransform().setLocalPosition(pos);
        
        // Keep flowers upright (no rotation during dance)
        var rotation = flower.getTransform().getLocalRotation();
        rotation.z = 0; // Keep upright
        flower.getTransform().setLocalRotation(rotation);
    }
}

// Check if flower landed in vase
function checkLanding(flowerX) {
    return flowerX >= vaseLeftBound && flowerX <= vaseRightBound;
}

// Show success feedback
function showSuccess() {
    if (script.successText) {
        if (currentFlower < totalFlowers) {
            script.successText.text = "Yayy~";
        } else {
            script.successText.text = "All Done! ðŸŒ¸ðŸŒ¸ðŸŒ¸ðŸŒ¸";
        }
        script.successText.enabled = true;
    }
    print("ðŸŒ¸ Success! Flower " + currentFlower + " landed in vase!");
    
    // If not the last flower, advance after 2 seconds
    if (currentFlower < totalFlowers) {
        var delayedEvent = script.createEvent("DelayedCallbackEvent");
        delayedEvent.bind(function() {
            // Hide success message
            if (script.successText) script.successText.enabled = false;
            // Advance to next flower
            nextFlower();
        });
        delayedEvent.reset(2.0); // 2 second delay
    } else {
        // All flowers completed - start celebration after 2 seconds
        var celebrationEvent = script.createEvent("DelayedCallbackEvent");
        celebrationEvent.bind(function() {
            startCelebration();
        });
        celebrationEvent.reset(2.0);
    }
}

// Show failure feedback
function showFailure() {
    failed = true;
    if (script.failText) {
        script.failText.text = "Oops :(";
        script.failText.enabled = true;
    }
    if (script.retryButton) {
        script.retryButton.enabled = true;
    }
    print("ðŸ’” Missed the vase! Tap anywhere to retry.");
}

function onUpdate(eventData) {
    // Handle celebration dance
    if (celebrating) {
        updateCelebration();
        return;
    }
    
    if (!currentFlowerObj) return;
    if (stopped || gameOver) return;
    var pos = currentFlowerObj.getTransform().getLocalPosition();

    if (!isDropping) {
        // Update pendulum angle
        currentAngle += angleDirection * swingSpeed;
        
        // Reverse direction when hitting the limits
        if (currentAngle >= maxAngle || currentAngle <= -maxAngle) {
            angleDirection *= -1;
        }
        
        // Convert angle to radians
        var angleRad = currentAngle * (Math.PI / 180);
        
        // Calculate position based on pendulum motion
        // Pivot is below the flower, so flower rotates around lower point
        // x = sin(angle) * armLength
        // y = pivotY + cos(angle) * armLength
        pos.x = Math.sin(angleRad) * armLength;
        pos.y = pivotY + Math.cos(angleRad) * armLength;
        
        // Also rotate the flower object to match the pendulum angle
        var transform = currentFlowerObj.getTransform();
        var rotation = transform.getLocalRotation();
        rotation.z = -angleRad; // Negative to match the visual rotation
        transform.setLocalRotation(rotation);
    } else {
        // Drop vertically
        pos.y -= dropSpeed;

        if (pos.y <= groundY) {
            pos.y = groundY;
            isDropping = false;
            stopped = true;
            gameOver = true;
            
            // Check if flower landed in vase
            if (checkLanding(pos.x)) {
                // Keep the flower in the vase (don't hide it)
                showSuccess();
            } else {
                showFailure();
            }
        }
    }
    
    currentFlowerObj.getTransform().setLocalPosition(pos);
}

// Initialize the game
setCurrentFlower(); // Set first flower
updateSwingSpeed(); // Set initial speed
initializeUI();

script.createEvent("UpdateEvent").bind(onUpdate);

script.createEvent("TapEvent").bind(function () {
    if (celebrating) {
        // During celebration, tap resets the entire game
        if (script.retryButton && script.retryButton.enabled) {
            print("Restarting entire game!");
            resetGame();
        }
        return;
    }
    
    if (failed) {
        // If game failed, any tap will retry current flower
        print("Retrying flower " + currentFlower + "!");
        // Reset current flower (don't go back to flower 1)
        isDropping = false;
        stopped = false;
        gameOver = false;
        failed = false;
        currentAngle = -maxAngle;
        angleDirection = 1;
        
        // Reset flower position
        resetFlowerPosition();
        
        // Hide UI elements
        initializeUI();
        return;
    }
    
    if (gameOver) return; // Prevent tapping when game is over (success case)
    
    print("Tapped!");
    isDropping = true;
    print("Starting drop");
});
